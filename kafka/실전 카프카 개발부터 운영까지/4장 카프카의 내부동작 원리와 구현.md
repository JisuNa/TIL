# 4장 카프카의 내부동작 원리와 구현

## 카프카 리플리케이션

동작 개요

리플리케이션은 토픽 생성시에 필수값으로 설정해야함

## 리더와 팔로워
리플리케이션을 리더와 팔로워로 나누며 리더는 하나이고 모든 읽기 쓰기는 리더만 함

프로듀서는 리더에게 메시지를 보내고 컨슈머도 리더에게서만 메시지를 받음

팔로워들은 리더 장애 발생시 다음 리더가 되기위한 준비를 함

## 복제유지와 커밋
리더와 팔로워는 ISR(In sync Replica)라는 논리적인 그룹으로 묶여있음

해당 그룹에 속한 팔로워만 새로운 리더가 될 자격이 있다

ISR 내의 팔로워들은 리더와의 데이터 일치를 유지하기위해 지속적으로 리더의 데이터를 따라간다

하지만 팔로우가 장애등의 이유로 리더로부터 리플리케이션 못해 데이처 불일치가 발생할 수 있다

리더는 지속적으로 팔로우들이 리플리케이션 동작을 잘 하는지 감시한다

팔로우가 특정 시간만큼 복제를 하지 않으면 리더는 해당 팔로우를 ISR 그룹에서 추방한다

ISR 내의 모든 팔로워의 복제가 완료되면 리더는 커밋되었다는 표시를 하는데 마지막 커밋 오프셋 위치를 하이워터마크라고 부른다

커밋됐다는 의미는 모든 리플리케이션이 메시지를 저장했다는 의미

커밋된 메시지만 컨슈머가 읽어갈 수 있다. 일관성을 위해 커밋안된 메시지는 못읽게함

## 리더와 팔로워의 단계별 리플리케이션 동작
리더만 0번 오프셋에 message1 을 가지고 있는 상태에서 팔로워들은 리더에게 0번 오프셋 메시지 가져오기(fetch) 요청을 보내고 새 메시지 message1을 리플리케이션 한다. 이때 리더는 팔로워가 새 메시지를 잘 받았는지 알지못한다. 래빗엠큐는 미러(리플리케이션)이 메시지를 잘 받았는지 ACK를 받아서 확인한다.
카프카는 ack를 보내지 않는다. 0번 오프셋을 받은 팔로워는 리더에게 1번 오프셋을 요청한다. 이때 리더는 팔로워가 0번 오프셋에 대한 리플리케이션 동작이 성공했다고 판단한다. 그리고 오프셋 0번에 커밋 표시하고 하이워터마크를 증가 시킨다.
팔로워로부터 1번 오프셋 요청을 받으면 리더는 응답에 0번 오프셋이 커밋됐다는 내용도 함께 전달한다.

카프카는 리더가 팔로워에게 리플리케이션 할 때 푸쉬 방식이 아니라 풀방식으로 동작하는데 리플리케이션 동작할 때 리더의 부하를 줄여준다

## 리더에포크와 복구
리더에포크는 파티션들이 복구동작을 할 때 메시지의 일관성을 유지하기 위해 사용한다
리더에포크는 컨트롤러에 의해 관리되는 32비트 의 숫자로 표현
리더가 변경되면 그 정도를 팔로워들에게 전달한다
리더에포크는 복구동작할 때 하이워터마크를 대체한다
